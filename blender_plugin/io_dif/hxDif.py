# Generated by Haxe 4.3.4
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import traceback as python_lib_Traceback


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class AISpecialNode:
    _hx_class_name = "AISpecialNode"
    __slots__ = ("name", "position")
    _hx_fields = ["name", "position"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,name,position):
        self.name = name
        self.position = position

    def write(self,io):
        io.writeStr(self.name)
        self.position.write(io)

    @staticmethod
    def read(io):
        return AISpecialNode(io.readStr(),math_Point3F.read(io))



class AnimatedLight:
    _hx_class_name = "AnimatedLight"
    __slots__ = ("nameIndex", "stateIndex", "stateCount", "flags", "duration")
    _hx_fields = ["nameIndex", "stateIndex", "stateCount", "flags", "duration"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,nameIndex,stateIndex,stateCount,flags,duration):
        self.nameIndex = nameIndex
        self.stateIndex = stateIndex
        self.stateCount = stateCount
        self.flags = flags
        self.duration = duration

    def write(self,io):
        io.writeInt32(self.nameIndex)
        io.writeInt32(self.stateIndex)
        io.writeUInt16(self.stateCount)
        io.writeUInt16(self.flags)
        io.writeInt32(self.duration)

    @staticmethod
    def read(io):
        return AnimatedLight(io.readInt32(),io.readInt32(),io.readInt16(),io.readInt16(),io.readInt32())



class BSPNode:
    _hx_class_name = "BSPNode"
    __slots__ = ("planeIndex", "frontIndex", "backIndex", "isFrontLeaf", "isFrontSolid", "isBackLeaf", "isBackSolid")
    _hx_fields = ["planeIndex", "frontIndex", "backIndex", "isFrontLeaf", "isFrontSolid", "isBackLeaf", "isBackSolid"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,planeIndex,frontIndex,backIndex,isFrontLeaf,isFrontSolid,isBackLeaf,isBackSolid):
        self.planeIndex = planeIndex
        self.frontIndex = frontIndex
        self.backIndex = backIndex
        self.isFrontLeaf = isFrontLeaf
        self.isFrontSolid = isFrontSolid
        self.isBackLeaf = isBackLeaf
        self.isBackSolid = isBackSolid

    def write(self,io,version):
        io.writeUInt16(self.planeIndex)
        if (version.interiorVersion >= 14):
            frontwrite = self.frontIndex
            frontwrite = self.frontIndex
            if self.isFrontLeaf:
                frontwrite = (frontwrite & -32769)
                frontwrite = (frontwrite | 524288)
            if self.isFrontSolid:
                frontwrite = (frontwrite & -16385)
                frontwrite = (frontwrite | 262144)
            io.writeInt32(frontwrite)
            backwrite = self.backIndex
            if self.isBackLeaf:
                backwrite = (backwrite & -32769)
                backwrite = (backwrite | 524288)
            if self.isBackSolid:
                backwrite = (backwrite & -16385)
                backwrite = (backwrite | 262144)
            io.writeInt32(backwrite)
        else:
            io.writeInt16(self.frontIndex)
            io.writeInt16(self.backIndex)

    @staticmethod
    def read(io,version):
        planeIndex = io.readUInt16()
        frontIndex = None
        backIndex = None
        isfrontleaf = False
        isfrontsolid = False
        isbackleaf = False
        isbacksolid = False
        if (version.interiorVersion >= 14):
            frontIndex = io.readInt32()
            backIndex = io.readInt32()
            if (((frontIndex & 524288)) != 0):
                frontIndex = ((frontIndex & -524289) | 32768)
                isfrontleaf = True
            if (((frontIndex & 262144)) != 0):
                frontIndex = ((frontIndex & -262145) | 16384)
                isfrontsolid = True
            if (((backIndex & 524288)) != 0):
                backIndex = ((backIndex & -524289) | 32768)
                isbackleaf = True
            if (((backIndex & 262144)) != 0):
                backIndex = ((backIndex & -262145) | 16384)
                isbacksolid = True
        else:
            frontIndex = io.readUInt16()
            backIndex = io.readUInt16()
            if (((frontIndex & 32768)) != 0):
                isfrontleaf = True
            if (((frontIndex & 16384)) != 0):
                isfrontsolid = True
            if (((backIndex & 32768)) != 0):
                isbackleaf = True
            if (((backIndex & 16384)) != 0):
                isbacksolid = True
        return BSPNode(planeIndex,frontIndex,backIndex,isfrontleaf,isfrontsolid,isbackleaf,isbacksolid)



class BSPSolidLeaf:
    _hx_class_name = "BSPSolidLeaf"
    __slots__ = ("surfaceStart", "surfaceCount")
    _hx_fields = ["surfaceStart", "surfaceCount"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,surfaceStart,surfaceCount):
        self.surfaceStart = surfaceStart
        self.surfaceCount = surfaceCount

    def write(self,io):
        io.writeInt32(self.surfaceStart)
        io.writeInt16(self.surfaceCount)

    @staticmethod
    def read(io):
        return BSPSolidLeaf(io.readInt32(),io.readInt16())



class Class: pass


class ConvexHull:
    _hx_class_name = "ConvexHull"
    __slots__ = ("hullStart", "hullCount", "minX", "minY", "minZ", "maxX", "maxY", "maxZ", "surfaceStart", "surfaceCount", "planeStart", "polyListPlaneStart", "polyListPointStart", "polyListStringStart", "staticMesh")
    _hx_fields = ["hullStart", "hullCount", "minX", "minY", "minZ", "maxX", "maxY", "maxZ", "surfaceStart", "surfaceCount", "planeStart", "polyListPlaneStart", "polyListPointStart", "polyListStringStart", "staticMesh"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.hullStart = 0
        self.hullCount = 0
        self.minX = 0
        self.minY = 0
        self.minZ = 0
        self.maxX = 0
        self.maxY = 0
        self.maxZ = 0
        self.surfaceStart = 0
        self.surfaceCount = 0
        self.planeStart = 0
        self.polyListPlaneStart = 0
        self.polyListPointStart = 0
        self.polyListStringStart = 0
        self.staticMesh = False

    def write(self,io,version):
        io.writeInt32(self.hullStart)
        io.writeUInt16(self.hullCount)
        io.writeFloat(self.minX)
        io.writeFloat(self.minY)
        io.writeFloat(self.minZ)
        io.writeFloat(self.maxX)
        io.writeFloat(self.maxY)
        io.writeFloat(self.maxZ)
        io.writeInt32(self.surfaceStart)
        io.writeUInt16(self.surfaceCount)
        io.writeInt32(self.planeStart)
        io.writeInt32(self.polyListPlaneStart)
        io.writeInt32(self.polyListPointStart)
        io.writeInt32(self.polyListStringStart)
        if (version.interiorVersion >= 12):
            io.writeByte((1 if (self.staticMesh) else 0))

    @staticmethod
    def read(io,version):
        ret = ConvexHull()
        ret.hullStart = io.readInt32()
        ret.hullCount = io.readUInt16()
        ret.minX = io.readFloat()
        ret.minY = io.readFloat()
        ret.minZ = io.readFloat()
        ret.maxX = io.readFloat()
        ret.maxY = io.readFloat()
        ret.maxZ = io.readFloat()
        ret.surfaceStart = io.readInt32()
        ret.surfaceCount = io.readUInt16()
        ret.planeStart = io.readInt32()
        ret.polyListPlaneStart = io.readInt32()
        ret.polyListPointStart = io.readInt32()
        ret.polyListStringStart = io.readInt32()
        if (version.interiorVersion >= 12):
            ret.staticMesh = (io.readByte() > 0)
        return ret



class CoordBin:
    _hx_class_name = "CoordBin"
    __slots__ = ("binStart", "binCount")
    _hx_fields = ["binStart", "binCount"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.binStart = 0
        self.binCount = 0

    def write(self,io):
        io.writeInt32(self.binStart)
        io.writeInt32(self.binCount)

    @staticmethod
    def read(io):
        ret = CoordBin()
        ret.binStart = io.readInt32()
        ret.binCount = io.readInt32()
        return ret



class Dif:
    _hx_class_name = "Dif"
    __slots__ = ("difVersion", "previewIncluded", "interiors", "subObjects", "triggers", "interiorPathfollowers", "forceFields", "aiSpecialNodes", "vehicleCollision", "gameEntities")
    _hx_fields = ["difVersion", "previewIncluded", "interiors", "subObjects", "triggers", "interiorPathfollowers", "forceFields", "aiSpecialNodes", "vehicleCollision", "gameEntities"]
    _hx_methods = ["write"]
    _hx_statics = ["Load", "Save", "LoadFromBuffer", "SaveToBuffer", "LoadFromByteArray", "SaveToByteArray", "read"]

    def __init__(self):
        self.aiSpecialNodes = None
        self.forceFields = None
        self.interiorPathfollowers = None
        self.triggers = None
        self.subObjects = None
        self.interiors = None
        self.previewIncluded = None
        self.difVersion = None
        self.gameEntities = None
        self.vehicleCollision = None

    def write(self,io,version):
        io.writeInt32(self.difVersion)
        io.writeByte(self.previewIncluded)
        def _hx_local_0(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.interiors,_hx_local_0)
        def _hx_local_1(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.subObjects,_hx_local_1)
        def _hx_local_2(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.triggers,_hx_local_2)
        def _hx_local_3(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.interiorPathfollowers,_hx_local_3)
        def _hx_local_4(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.forceFields,_hx_local_4)
        def _hx_local_5(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.aiSpecialNodes,_hx_local_5)
        if (self.vehicleCollision is not None):
            io.writeInt32(1)
            self.vehicleCollision.write(io,version)
        else:
            io.writeInt32(0)
        if (self.gameEntities is not None):
            io.writeInt32(2)
            def _hx_local_6(io,p):
                p.write(io)
            WriterExtensions.writeArray(io,self.gameEntities,_hx_local_6)
        else:
            io.writeInt32(0)
        io.writeInt32(0)

    @staticmethod
    def Load(path):
        f = sys_io_File.read(path)
        _hx_bytes = f.readAll()
        br = io_BytesReader(_hx_bytes)
        return Dif.read(br)

    @staticmethod
    def Save(dif,version,path):
        f = sys_io_File.write(path)
        bw = io_BytesWriter()
        dif.write(bw,version)
        f.write(bw.getBuffer())

    @staticmethod
    def LoadFromBuffer(buffer):
        br = io_BytesReader(buffer)
        return Dif.read(br)

    @staticmethod
    def SaveToBuffer(dif,version):
        bw = io_BytesWriter()
        dif.write(bw,version)
        return bw.getBuffer()

    @staticmethod
    def LoadFromByteArray(buffer):
        br = io_BytesReader(haxe_io_Bytes.ofData(buffer))
        return Dif.read(br)

    @staticmethod
    def SaveToByteArray(dif,version):
        bw = io_BytesWriter()
        dif.write(bw,version)
        return bw.getBuffer().b

    @staticmethod
    def read(io):
        ret = Dif()
        version = Version()
        version.difVersion = io.readInt32()
        ret.difVersion = version.difVersion
        ret.previewIncluded = io.readByte()
        def _hx_local_0(io):
            return Interior.read(io,version)
        ret.interiors = ReaderExtensions.readArray(io,_hx_local_0)
        def _hx_local_1(io):
            return Interior.read(io,version)
        ret.subObjects = ReaderExtensions.readArray(io,_hx_local_1)
        ret.triggers = ReaderExtensions.readArray(io,Trigger.read)
        ret.interiorPathfollowers = ReaderExtensions.readArray(io,InteriorPathFollower.read)
        ret.forceFields = ReaderExtensions.readArray(io,ForceField.read)
        ret.aiSpecialNodes = ReaderExtensions.readArray(io,AISpecialNode.read)
        readVehicleCollision = io.readInt32()
        if (readVehicleCollision == 1):
            ret.vehicleCollision = VehicleCollision.read(io,version)
        readGameEntities = io.readInt32()
        if (readGameEntities == 2):
            ret.gameEntities = ReaderExtensions.readArray(io,GameEntity.read)
        return ret



class Edge:
    _hx_class_name = "Edge"
    __slots__ = ("pointIndex0", "pointIndex1", "surfaceIndex0", "surfaceIndex1")
    _hx_fields = ["pointIndex0", "pointIndex1", "surfaceIndex0", "surfaceIndex1"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,pointIndex0,pointIndex1,surfaceIndex0,surfaceIndex1):
        self.pointIndex0 = pointIndex0
        self.pointIndex1 = pointIndex1
        self.surfaceIndex0 = surfaceIndex0
        self.surfaceIndex1 = surfaceIndex1

    def write(self,io,version):
        io.writeInt32(self.pointIndex0)
        io.writeInt32(self.pointIndex1)
        io.writeInt32(self.surfaceIndex0)
        io.writeInt32(self.surfaceIndex1)

    @staticmethod
    def read(io,version):
        return Edge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32())



class Edge2:
    _hx_class_name = "Edge2"
    __slots__ = ("vertex0", "vertex1", "normal0", "normal1", "face0", "face1")
    _hx_fields = ["vertex0", "vertex1", "normal0", "normal1", "face0", "face1"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.vertex0 = 0
        self.vertex1 = 0
        self.normal0 = 0
        self.normal1 = 0
        self.face0 = 0
        self.face1 = 0

    def write(self,io,version):
        io.writeInt32(self.vertex0)
        io.writeInt32(self.vertex1)
        io.writeInt32(self.normal0)
        io.writeInt32(self.normal1)
        if (version.interiorVersion >= 3):
            io.writeInt32(self.face0)
            io.writeInt32(self.face1)

    @staticmethod
    def read(io,version):
        ret = Edge2()
        ret.vertex0 = io.readInt32()
        ret.vertex1 = io.readInt32()
        ret.normal0 = io.readInt32()
        ret.normal1 = io.readInt32()
        if (version.interiorVersion >= 3):
            ret.face0 = io.readInt32()
            ret.face1 = io.readInt32()
        return ret



class FFSurface:
    _hx_class_name = "FFSurface"
    __slots__ = ("windingStart", "windingCount", "planeIndex", "surfaceFlags", "fanMask")
    _hx_fields = ["windingStart", "windingCount", "planeIndex", "surfaceFlags", "fanMask"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.windingStart = 0
        self.windingCount = 0
        self.planeIndex = 0
        self.surfaceFlags = 0
        self.fanMask = 0

    def write(self,io):
        io.writeInt32(self.windingStart)
        io.writeByte(self.windingCount)
        io.writeInt16(self.planeIndex)
        io.writeByte(self.surfaceFlags)
        io.writeInt32(self.fanMask)

    @staticmethod
    def read(io):
        ret = FFSurface()
        ret.windingStart = io.readInt32()
        ret.windingCount = io.readByte()
        ret.planeIndex = io.readInt16()
        ret.surfaceFlags = io.readByte()
        ret.fanMask = io.readInt32()
        return ret



class ForceField:
    _hx_class_name = "ForceField"
    __slots__ = ("forceFieldFileVersion", "name", "triggers", "boundingBox", "boundingSphere", "normals", "planes", "bspNodes", "bspSolidLeaves", "windings", "surfaces", "solidLeafSurfaces", "color")
    _hx_fields = ["forceFieldFileVersion", "name", "triggers", "boundingBox", "boundingSphere", "normals", "planes", "bspNodes", "bspSolidLeaves", "windings", "surfaces", "solidLeafSurfaces", "color"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.color = None
        self.solidLeafSurfaces = None
        self.surfaces = None
        self.windings = None
        self.bspSolidLeaves = None
        self.bspNodes = None
        self.planes = None
        self.normals = None
        self.boundingSphere = None
        self.boundingBox = None
        self.triggers = None
        self.name = None
        self.forceFieldFileVersion = None

    def write(self,io):
        io.writeInt32(self.forceFieldFileVersion)
        io.writeStr(self.name)
        def _hx_local_0(io,p):
            io.writeStr(p)
        WriterExtensions.writeArray(io,self.triggers,_hx_local_0)
        self.boundingBox.write(io)
        self.boundingSphere.write(io)
        def _hx_local_1(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.normals,_hx_local_1)
        def _hx_local_2(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.planes,_hx_local_2)
        def _hx_local_3(io,p):
            p.write(io,Version())
        WriterExtensions.writeArray(io,self.bspNodes,_hx_local_3)
        def _hx_local_4(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.bspSolidLeaves,_hx_local_4)
        def _hx_local_5(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.windings,_hx_local_5)
        def _hx_local_6(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.surfaces,_hx_local_6)
        def _hx_local_7(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.solidLeafSurfaces,_hx_local_7)
        WriterExtensions.writeColorF(io,self.color)

    @staticmethod
    def read(io):
        ret = ForceField()
        ret.forceFieldFileVersion = io.readInt32()
        ret.name = io.readStr()
        def _hx_local_0(io):
            return io.readStr()
        ret.triggers = ReaderExtensions.readArray(io,_hx_local_0)
        ret.boundingBox = math_Box3F.read(io)
        ret.boundingSphere = math_Spheref.read(io)
        ret.normals = ReaderExtensions.readArray(io,math_Point3F.read)
        ret.planes = ReaderExtensions.readArray(io,Plane.read)
        def _hx_local_1(io):
            return BSPNode.read(io,Version())
        ret.bspNodes = ReaderExtensions.readArray(io,_hx_local_1)
        ret.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read)
        def _hx_local_2(io):
            return io.readInt32()
        ret.windings = ReaderExtensions.readArray(io,_hx_local_2)
        ret.surfaces = ReaderExtensions.readArray(io,FFSurface.read)
        def _hx_local_3(io):
            return io.readInt32()
        ret.solidLeafSurfaces = ReaderExtensions.readArray(io,_hx_local_3)
        ret.color = ReaderExtensions.readColorF(io)
        return ret



class GameEntity:
    _hx_class_name = "GameEntity"
    __slots__ = ("datablock", "gameClass", "position", "properties")
    _hx_fields = ["datablock", "gameClass", "position", "properties"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.datablock = ""
        self.gameClass = ""
        self.position = math_Point3F()
        self.properties = haxe_ds_StringMap()

    def write(self,io):
        io.writeStr(self.datablock)
        io.writeStr(self.gameClass)
        self.position.write(io)
        WriterExtensions.writeDictionary(io,self.properties)

    @staticmethod
    def read(io):
        ret = GameEntity()
        ret.datablock = io.readStr()
        ret.gameClass = io.readStr()
        ret.position = math_Point3F.read(io)
        ret.properties = ReaderExtensions.readDictionary(io)
        return ret



class Interior:
    _hx_class_name = "Interior"
    __slots__ = ("detailLevel", "minPixels", "boundingBox", "boundingSphere", "hasAlarmState", "numLightStateEntries", "normals", "planes", "points", "pointVisibilities", "texGenEQs", "bspNodes", "bspSolidLeaves", "materialListVersion", "materialList", "windings", "windingIndices", "edges", "zones", "zoneSurfaces", "zoneStaticMeshes", "zonePortalList", "portals", "surfaces", "edges2", "normals2", "normalIndices", "normalLMapIndices", "alarmLMapIndices", "nullSurfaces", "lightMaps", "solidLeafSurfaces", "animatedLights", "lightStates", "stateDatas", "stateDataFlags", "stateDataBuffers", "nameBuffer", "subObjects", "convexHulls", "convexHullEmitStrings", "hullIndices", "hullPlaneIndices", "hullEmitStringIndices", "hullSurfaceIndices", "polyListPlanes", "polyListPoints", "polyListStrings", "coordBins", "coordBinIndices", "coordBinMode", "baseAmbientColor", "alarmAmbientColor", "numStaticMeshes", "texNormals", "texMatrices", "texMatIndices", "extendedLightMapData", "lightMapBorderSize")
    _hx_fields = ["detailLevel", "minPixels", "boundingBox", "boundingSphere", "hasAlarmState", "numLightStateEntries", "normals", "planes", "points", "pointVisibilities", "texGenEQs", "bspNodes", "bspSolidLeaves", "materialListVersion", "materialList", "windings", "windingIndices", "edges", "zones", "zoneSurfaces", "zoneStaticMeshes", "zonePortalList", "portals", "surfaces", "edges2", "normals2", "normalIndices", "normalLMapIndices", "alarmLMapIndices", "nullSurfaces", "lightMaps", "solidLeafSurfaces", "animatedLights", "lightStates", "stateDatas", "stateDataFlags", "stateDataBuffers", "nameBuffer", "subObjects", "convexHulls", "convexHullEmitStrings", "hullIndices", "hullPlaneIndices", "hullEmitStringIndices", "hullSurfaceIndices", "polyListPlanes", "polyListPoints", "polyListStrings", "coordBins", "coordBinIndices", "coordBinMode", "baseAmbientColor", "alarmAmbientColor", "numStaticMeshes", "texNormals", "texMatrices", "texMatIndices", "extendedLightMapData", "lightMapBorderSize"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.lightMapBorderSize = None
        self.extendedLightMapData = None
        self.texMatIndices = None
        self.texMatrices = None
        self.texNormals = None
        self.numStaticMeshes = None
        self.alarmAmbientColor = None
        self.baseAmbientColor = None
        self.coordBinMode = None
        self.coordBinIndices = None
        self.coordBins = None
        self.polyListStrings = None
        self.polyListPoints = None
        self.polyListPlanes = None
        self.hullSurfaceIndices = None
        self.hullEmitStringIndices = None
        self.hullPlaneIndices = None
        self.hullIndices = None
        self.convexHullEmitStrings = None
        self.convexHulls = None
        self.subObjects = None
        self.nameBuffer = None
        self.stateDataBuffers = None
        self.stateDataFlags = None
        self.stateDatas = None
        self.lightStates = None
        self.animatedLights = None
        self.solidLeafSurfaces = None
        self.lightMaps = None
        self.nullSurfaces = None
        self.alarmLMapIndices = None
        self.normalLMapIndices = None
        self.normalIndices = None
        self.normals2 = None
        self.edges2 = None
        self.surfaces = None
        self.portals = None
        self.zonePortalList = None
        self.zoneStaticMeshes = None
        self.zoneSurfaces = None
        self.zones = None
        self.edges = None
        self.windingIndices = None
        self.windings = None
        self.materialList = None
        self.materialListVersion = None
        self.bspSolidLeaves = None
        self.bspNodes = None
        self.texGenEQs = None
        self.pointVisibilities = None
        self.points = None
        self.planes = None
        self.normals = None
        self.numLightStateEntries = None
        self.hasAlarmState = None
        self.boundingSphere = None
        self.boundingBox = None
        self.minPixels = None
        self.detailLevel = None

    def write(self,io,version):
        io.writeInt32(version.interiorVersion)
        io.writeInt32(self.detailLevel)
        io.writeInt32(self.minPixels)
        self.boundingBox.write(io)
        self.boundingSphere.write(io)
        io.writeByte(self.hasAlarmState)
        io.writeInt32(self.numLightStateEntries)
        def _hx_local_0(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.normals,_hx_local_0)
        def _hx_local_1(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.planes,_hx_local_1)
        def _hx_local_2(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.points,_hx_local_2)
        if (version.interiorVersion != 4):
            def _hx_local_3(io,p):
                io.writeByte(p)
            WriterExtensions.writeArray(io,self.pointVisibilities,_hx_local_3)
        def _hx_local_4(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.texGenEQs,_hx_local_4)
        def _hx_local_5(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.bspNodes,_hx_local_5)
        def _hx_local_6(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.bspSolidLeaves,_hx_local_6)
        io.writeByte(self.materialListVersion)
        def _hx_local_7(io,p):
            io.writeStr(p)
        WriterExtensions.writeArray(io,self.materialList,_hx_local_7)
        def _hx_local_8(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.windings,_hx_local_8)
        def _hx_local_9(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.windingIndices,_hx_local_9)
        if (version.interiorVersion >= 12):
            def _hx_local_10(io,p):
                p.write(io,version)
            WriterExtensions.writeArray(io,self.edges,_hx_local_10)
        def _hx_local_11(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.zones,_hx_local_11)
        def _hx_local_12(io,p):
            io.writeUInt16(p)
        WriterExtensions.writeArray(io,self.zoneSurfaces,_hx_local_12)
        if (version.interiorVersion >= 12):
            def _hx_local_13(io,p):
                io.writeInt32(p)
            WriterExtensions.writeArray(io,self.zoneStaticMeshes,_hx_local_13)
        def _hx_local_14(io,p):
            io.writeUInt16(p)
        WriterExtensions.writeArray(io,self.zonePortalList,_hx_local_14)
        def _hx_local_15(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.portals,_hx_local_15)
        def _hx_local_16(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.surfaces,_hx_local_16)
        if ((version.interiorVersion >= 2) and ((version.interiorVersion <= 5))):
            def _hx_local_17(io,p):
                p.write(io,version)
            WriterExtensions.writeArray(io,self.edges2,_hx_local_17)
            if ((version.interiorVersion >= 4) and ((version.interiorVersion <= 5))):
                def _hx_local_18(io,p):
                    p.write(io)
                WriterExtensions.writeArray(io,self.normals2,_hx_local_18)
                def _hx_local_19(io,p):
                    io.writeUInt16(p)
                WriterExtensions.writeArray(io,self.normalIndices,_hx_local_19)
        if (version.interiorVersion == 4):
            def _hx_local_20(io,p):
                io.writeByte(p)
            WriterExtensions.writeArray(io,self.normalLMapIndices,_hx_local_20)
        elif (version.interiorVersion >= 13):
            def _hx_local_21(io,p):
                io.writeInt32(p)
            WriterExtensions.writeArray(io,self.normalLMapIndices,_hx_local_21)
            def _hx_local_22(io,p):
                io.writeInt32(p)
            WriterExtensions.writeArray(io,self.alarmLMapIndices,_hx_local_22)
        else:
            def _hx_local_23(io,p):
                io.writeByte((p & 255))
            WriterExtensions.writeArray(io,self.normalLMapIndices,_hx_local_23)
            def _hx_local_24(io,p):
                io.writeByte((p & 255))
            WriterExtensions.writeArray(io,self.alarmLMapIndices,_hx_local_24)
        def _hx_local_25(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.nullSurfaces,_hx_local_25)
        if (version.interiorVersion != 4):
            def _hx_local_26(io,p):
                p.writeLightMap(io,version)
            WriterExtensions.writeArray(io,self.lightMaps,_hx_local_26)
        def _hx_local_27(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.solidLeafSurfaces,_hx_local_27)
        def _hx_local_28(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.animatedLights,_hx_local_28)
        def _hx_local_29(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.lightStates,_hx_local_29)
        if (version.interiorVersion != 4):
            def _hx_local_30(io,p):
                p.write(io)
            WriterExtensions.writeArray(io,self.stateDatas,_hx_local_30)
            def _hx_local_31(io,p):
                io.writeByte(p)
            WriterExtensions.writeArrayFlags(io,self.stateDataBuffers,self.stateDataFlags,_hx_local_31)
            def _hx_local_32(io,p):
                io.writeByte(p)
            WriterExtensions.writeArray(io,self.nameBuffer,_hx_local_32)
            io.writeInt32(len(self.subObjects))
            _g = 0
            _g1 = len(self.subObjects)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                io.writeInt32(1)
                (self.subObjects[i] if i >= 0 and i < len(self.subObjects) else None).write(io,version)
        def _hx_local_33(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.convexHulls,_hx_local_33)
        def _hx_local_34(io,p):
            io.writeByte(p)
        WriterExtensions.writeArray(io,self.convexHullEmitStrings,_hx_local_34)
        def _hx_local_35(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullIndices,_hx_local_35)
        def _hx_local_36(io,p):
            io.writeInt16(p)
        WriterExtensions.writeArray(io,self.hullPlaneIndices,_hx_local_36)
        def _hx_local_37(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullEmitStringIndices,_hx_local_37)
        def _hx_local_38(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullSurfaceIndices,_hx_local_38)
        def _hx_local_39(io,p):
            io.writeInt16(p)
        WriterExtensions.writeArray(io,self.polyListPlanes,_hx_local_39)
        def _hx_local_40(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.polyListPoints,_hx_local_40)
        def _hx_local_41(io,p):
            io.writeByte(p)
        WriterExtensions.writeArray(io,self.polyListStrings,_hx_local_41)
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            (self.coordBins[i] if i >= 0 and i < len(self.coordBins) else None).write(io)
        def _hx_local_42(io,p):
            io.writeInt16(p)
        WriterExtensions.writeArray(io,self.coordBinIndices,_hx_local_42)
        io.writeInt32(self.coordBinMode)
        if (version.interiorVersion != 4):
            WriterExtensions.writeColorF(io,self.baseAmbientColor)
            WriterExtensions.writeColorF(io,self.alarmAmbientColor)
            if (version.interiorVersion >= 10):
                io.writeInt32(self.numStaticMeshes)
            if (version.interiorVersion >= 11):
                def _hx_local_43(io,p):
                    p.write(io)
                WriterExtensions.writeArray(io,self.texNormals,_hx_local_43)
                def _hx_local_44(io,p):
                    p.write(io)
                WriterExtensions.writeArray(io,self.texNormals,_hx_local_44)
                def _hx_local_45(io,p):
                    io.writeInt32(p)
                WriterExtensions.writeArray(io,self.texMatIndices,_hx_local_45)
            else:
                io.writeInt32(0)
                io.writeInt32(0)
                io.writeInt32(0)
            io.writeInt32(self.extendedLightMapData)
            if (self.extendedLightMapData > 0):
                io.writeInt32(self.lightMapBorderSize)
                io.writeInt32(0)

    @staticmethod
    def read(io,version):
        if (version.interiorType == "?"):
            version.interiorType = "tgea"
        version.interiorVersion = io.readInt32()
        it = Interior()
        it.detailLevel = io.readInt32()
        it.minPixels = io.readInt32()
        it.boundingBox = math_Box3F.read(io)
        it.boundingSphere = math_Spheref.read(io)
        it.hasAlarmState = io.readByte()
        it.numLightStateEntries = io.readInt32()
        it.normals = ReaderExtensions.readArray(io,math_Point3F.read)
        it.planes = ReaderExtensions.readArray(io,Plane.read)
        it.points = ReaderExtensions.readArray(io,math_Point3F.read)
        if (version.interiorVersion == 4):
            it.pointVisibilities = list()
        else:
            def _hx_local_0(io):
                return io.readByte()
            it.pointVisibilities = ReaderExtensions.readArray(io,_hx_local_0)
        it.texGenEQs = ReaderExtensions.readArray(io,TexGenEQ.read)
        def _hx_local_1(io):
            return BSPNode.read(io,version)
        it.bspNodes = ReaderExtensions.readArray(io,_hx_local_1)
        it.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read)
        it.materialListVersion = io.readByte()
        def _hx_local_2(io):
            return io.readStr()
        it.materialList = ReaderExtensions.readArray(io,_hx_local_2)
        def _hx_local_3(signed,param):
            return (param > 0)
        def _hx_local_4(io):
            return io.readInt32()
        def _hx_local_5(io):
            return io.readInt16()
        it.windings = ReaderExtensions.readArrayAs(io,_hx_local_3,_hx_local_4,_hx_local_5)
        it.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read)
        if (version.interiorVersion >= 12):
            def _hx_local_6(io):
                return Edge.read(io,version)
            it.edges = ReaderExtensions.readArray(io,_hx_local_6)
        def _hx_local_7(io):
            return Zone.read(io,version)
        it.zones = ReaderExtensions.readArray(io,_hx_local_7)
        def _hx_local_8(signed,param):
            return False
        def _hx_local_9(io):
            return io.readInt16()
        def _hx_local_10(io):
            return io.readInt16()
        it.zoneSurfaces = ReaderExtensions.readArrayAs(io,_hx_local_8,_hx_local_9,_hx_local_10)
        if (version.interiorVersion >= 12):
            def _hx_local_11(io):
                return io.readInt32()
            it.zoneStaticMeshes = ReaderExtensions.readArray(io,_hx_local_11)
        def _hx_local_12(signed,param):
            return False
        def _hx_local_13(io):
            return io.readInt16()
        def _hx_local_14(io):
            return io.readInt16()
        it.zonePortalList = ReaderExtensions.readArrayAs(io,_hx_local_12,_hx_local_13,_hx_local_14)
        it.portals = ReaderExtensions.readArray(io,Portal.read)
        pos = io.tell()
        try:
            def _hx_local_15(io):
                return Surface.read(io,version,it)
            it.surfaces = ReaderExtensions.readArray(io,_hx_local_15)
            if (version.interiorType == "?"):
                version.interiorType = "tge"
        except BaseException as _g:
            if (version.interiorType == "tgea"):
                version.interiorType = "tge"
            io.seek(pos)
            def _hx_local_16(io):
                return Surface.read(io,version,it)
            try:
                it.surfaces = ReaderExtensions.readArray(io,_hx_local_16)
            except BaseException as _g:
                version.useLargeLightmaps = True
                io.seek(pos)
                def _hx_local_17(io):
                    return Surface.read(io,version,it)
                try:
                    it.surfaces = ReaderExtensions.readArray(io,_hx_local_17)
                except BaseException as _g:
                    e = haxe_Exception.caught(_g)
                    raise haxe_Exception.thrown(e)
        if ((version.interiorVersion >= 2) and ((version.interiorVersion <= 5))):
            def _hx_local_18(io):
                return Edge2.read(io,version)
            it.edges2 = ReaderExtensions.readArray(io,_hx_local_18)
            if ((version.interiorVersion >= 4) and ((version.interiorVersion <= 5))):
                it.normals2 = ReaderExtensions.readArray(io,math_Point3F.read)
                def _hx_local_19(alt,param):
                    if alt:
                        return (param == 0)
                    else:
                        return False
                def _hx_local_20(io):
                    return io.readUInt16()
                def _hx_local_21(io):
                    return io.readByte()
                it.normalIndices = ReaderExtensions.readArrayAs(io,_hx_local_19,_hx_local_20,_hx_local_21)
        if (version.interiorVersion == 4):
            def _hx_local_22(io):
                return io.readByte()
            it.normalLMapIndices = ReaderExtensions.readArray(io,_hx_local_22)
            it.alarmLMapIndices = list()
        elif (version.interiorVersion >= 13):
            def _hx_local_23(io):
                return io.readInt32()
            it.normalLMapIndices = ReaderExtensions.readArray(io,_hx_local_23)
            def _hx_local_24(io):
                return io.readInt32()
            it.alarmLMapIndices = ReaderExtensions.readArray(io,_hx_local_24)
        else:
            def _hx_local_25(io):
                return io.readByte()
            it.normalLMapIndices = ReaderExtensions.readArray(io,_hx_local_25)
            def _hx_local_26(io):
                return io.readByte()
            it.alarmLMapIndices = ReaderExtensions.readArray(io,_hx_local_26)
        def _hx_local_27(io):
            return NullSurface.read(io,version)
        it.nullSurfaces = ReaderExtensions.readArray(io,_hx_local_27)
        if (version.interiorVersion != 4):
            def _hx_local_28(io):
                return LightMap.read(io,version)
            it.lightMaps = ReaderExtensions.readArray(io,_hx_local_28)
            if ((len(it.lightMaps) > 0) and ((version.interiorType == "mbg"))):
                version.interiorType = "tge"
        else:
            it.lightMaps = list()
        def _hx_local_29(alt,void):
            return alt
        def _hx_local_30(io):
            return io.readInt32()
        def _hx_local_31(io):
            return io.readUInt16()
        it.solidLeafSurfaces = ReaderExtensions.readArrayAs(io,_hx_local_29,_hx_local_30,_hx_local_31)
        it.animatedLights = ReaderExtensions.readArray(io,AnimatedLight.read)
        it.lightStates = ReaderExtensions.readArray(io,LightState.read)
        if (version.interiorVersion == 4):
            it.stateDatas = list()
            it.stateDataFlags = 0
            it.stateDataBuffers = list()
            it.subObjects = list()
        else:
            it.stateDatas = ReaderExtensions.readArray(io,StateData.read)
            def _hx_local_32(io):
                return io.readByte()
            it.stateDataBuffers = ReaderExtensions.readArrayFlags(io,_hx_local_32)
            def _hx_local_33(io):
                return io.readByte()
            it.nameBuffer = ReaderExtensions.readArray(io,_hx_local_33)
            it.stateDataFlags = 0
            def _hx_local_34(io):
                soKey = io.readInt32()
                if (soKey == 1):
                    return MirrorSubObject.read(io,version)
                else:
                    raise haxe_Exception("Unknown SubObject key: ")
            it.subObjects = ReaderExtensions.readArray(io,_hx_local_34)
        def _hx_local_35(io):
            return ConvexHull.read(io,version)
        it.convexHulls = ReaderExtensions.readArray(io,_hx_local_35)
        def _hx_local_36(io):
            return io.readByte()
        it.convexHullEmitStrings = ReaderExtensions.readArray(io,_hx_local_36)
        if (version.interiorVersion == 0):
            def _hx_local_37(io):
                return io.readInt32()
            it.hullIndices = ReaderExtensions.readArray(io,_hx_local_37)
        else:
            def _hx_local_38(alt,that):
                return alt
            def _hx_local_39(io):
                return io.readInt32()
            def _hx_local_40(io):
                return io.readUInt16()
            it.hullIndices = ReaderExtensions.readArrayAs(io,_hx_local_38,_hx_local_39,_hx_local_40)
        if (version.interiorVersion == 0):
            def _hx_local_41(io):
                return io.readUInt16()
            it.hullPlaneIndices = ReaderExtensions.readArray(io,_hx_local_41)
        else:
            def _hx_local_42(alt,that):
                return True
            def _hx_local_43(io):
                return io.readInt32()
            def _hx_local_44(io):
                return io.readUInt16()
            it.hullPlaneIndices = ReaderExtensions.readArrayAs(io,_hx_local_42,_hx_local_43,_hx_local_44)
        if (version.interiorVersion == 0):
            def _hx_local_45(io):
                return io.readInt32()
            it.hullEmitStringIndices = ReaderExtensions.readArray(io,_hx_local_45)
        else:
            def _hx_local_46(alt,that):
                return alt
            def _hx_local_47(io):
                return io.readInt32()
            def _hx_local_48(io):
                return io.readUInt16()
            it.hullEmitStringIndices = ReaderExtensions.readArrayAs(io,_hx_local_46,_hx_local_47,_hx_local_48)
        if (version.interiorVersion == 0):
            def _hx_local_49(io):
                return io.readInt32()
            it.hullSurfaceIndices = ReaderExtensions.readArray(io,_hx_local_49)
        else:
            def _hx_local_50(alt,that):
                return alt
            def _hx_local_51(io):
                return io.readInt32()
            def _hx_local_52(io):
                return io.readUInt16()
            it.hullSurfaceIndices = ReaderExtensions.readArrayAs(io,_hx_local_50,_hx_local_51,_hx_local_52)
        if (version.interiorVersion == 0):
            def _hx_local_53(io):
                return io.readUInt16()
            it.polyListPlanes = ReaderExtensions.readArray(io,_hx_local_53)
        else:
            def _hx_local_54(alt,that):
                return True
            def _hx_local_55(io):
                return io.readInt32()
            def _hx_local_56(io):
                return io.readUInt16()
            it.polyListPlanes = ReaderExtensions.readArrayAs(io,_hx_local_54,_hx_local_55,_hx_local_56)
        if (version.interiorVersion == 0):
            def _hx_local_57(io):
                return io.readInt32()
            it.polyListPoints = ReaderExtensions.readArray(io,_hx_local_57)
        else:
            def _hx_local_58(alt,that):
                return alt
            def _hx_local_59(io):
                return io.readInt32()
            def _hx_local_60(io):
                return io.readUInt16()
            it.polyListPoints = ReaderExtensions.readArrayAs(io,_hx_local_58,_hx_local_59,_hx_local_60)
        def _hx_local_61(io):
            return io.readByte()
        it.polyListStrings = ReaderExtensions.readArray(io,_hx_local_61)
        it.coordBins = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            _this = it.coordBins
            x = CoordBin.read(io)
            _this.append(x)
        def _hx_local_62(a,b):
            return True
        def _hx_local_63(io):
            return io.readUInt16()
        def _hx_local_64(io):
            return io.readUInt16()
        it.coordBinIndices = ReaderExtensions.readArrayAs(io,_hx_local_62,_hx_local_63,_hx_local_64)
        it.coordBinMode = io.readInt32()
        if (version.interiorVersion == 4):
            it.baseAmbientColor = [0, 0, 0, 255]
            it.alarmAmbientColor = [0, 0, 0, 255]
            it.extendedLightMapData = 0
            it.lightMapBorderSize = 0
        else:
            it.baseAmbientColor = ReaderExtensions.readColorF(io)
            it.alarmAmbientColor = ReaderExtensions.readColorF(io)
            if (version.interiorVersion >= 10):
                it.numStaticMeshes = io.readInt32()
            if (version.interiorVersion >= 11):
                it.texNormals = ReaderExtensions.readArray(io,math_Point3F.read)
                it.texMatrices = ReaderExtensions.readArray(io,TexMatrix.read)
                def _hx_local_65(io):
                    return io.readInt32()
                it.texMatIndices = ReaderExtensions.readArray(io,_hx_local_65)
            else:
                io.readInt32()
                io.readInt32()
                io.readInt32()
            it.extendedLightMapData = io.readInt32()
            if (it.extendedLightMapData > 0):
                it.lightMapBorderSize = io.readInt32()
                io.readInt32()
        return it



class InteriorPathFollower:
    _hx_class_name = "InteriorPathFollower"
    __slots__ = ("name", "datablock", "interiorResIndex", "offset", "properties", "triggerId", "wayPoint", "totalMS")
    _hx_fields = ["name", "datablock", "interiorResIndex", "offset", "properties", "triggerId", "wayPoint", "totalMS"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.name = ""
        self.datablock = ""
        self.interiorResIndex = 0
        self.offset = math_Point3F()
        self.properties = haxe_ds_StringMap()
        self.triggerId = list()
        self.wayPoint = list()
        self.totalMS = 0

    def write(self,io):
        io.writeStr(self.name)
        io.writeStr(self.datablock)
        io.writeInt32(self.interiorResIndex)
        self.offset.write(io)
        WriterExtensions.writeDictionary(io,self.properties)
        def _hx_local_0(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.triggerId,_hx_local_0)
        def _hx_local_1(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.wayPoint,_hx_local_1)
        io.writeInt32(self.totalMS)

    @staticmethod
    def read(io):
        ret = InteriorPathFollower()
        ret.name = io.readStr()
        ret.datablock = io.readStr()
        ret.interiorResIndex = io.readInt32()
        ret.offset = math_Point3F.read(io)
        ret.properties = ReaderExtensions.readDictionary(io)
        def _hx_local_0(io):
            return io.readInt32()
        ret.triggerId = ReaderExtensions.readArray(io,_hx_local_0)
        ret.wayPoint = ReaderExtensions.readArray(io,WayPoint.read)
        ret.totalMS = io.readInt32()
        return ret



class LightMap:
    _hx_class_name = "LightMap"
    __slots__ = ("lightmap", "lightdirmap", "keepLightMap")
    _hx_fields = ["lightmap", "lightdirmap", "keepLightMap"]
    _hx_methods = ["writeLightMap"]
    _hx_statics = ["read"]

    def __init__(self):
        self.lightmap = list()
        self.lightdirmap = list()
        self.keepLightMap = 0

    def writeLightMap(self,io,version):
        WriterExtensions.writePNG(io,self.lightmap)
        if ((version.interiorType != "mbg") and ((version.interiorType != "tge"))):
            WriterExtensions.writePNG(io,self.lightdirmap)
        io.writeByte(self.keepLightMap)

    @staticmethod
    def read(io,version):
        ret = LightMap()
        ret.lightmap = ReaderExtensions.readPNG(io)
        if ((version.interiorType != "mbg") and ((version.interiorType != "tge"))):
            ret.lightdirmap = ReaderExtensions.readPNG(io)
        ret.keepLightMap = io.readByte()
        return ret



class LightState:
    _hx_class_name = "LightState"
    __slots__ = ("red", "green", "blue", "activeTime", "dataIndex", "dataCount")
    _hx_fields = ["red", "green", "blue", "activeTime", "dataIndex", "dataCount"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,red,green,blue,activeTime,dataIndex,dataCount):
        self.red = red
        self.green = green
        self.blue = blue
        self.activeTime = activeTime
        self.dataIndex = dataIndex
        self.dataCount = dataCount

    def write(self,io):
        io.writeByte(self.red)
        io.writeByte(self.green)
        io.writeByte(self.blue)
        io.writeInt32(self.activeTime)
        io.writeInt32(self.dataIndex)
        io.writeInt16(self.dataCount)

    @staticmethod
    def read(io):
        return LightState(io.readByte(),io.readByte(),io.readByte(),io.readInt32(),io.readInt32(),io.readInt16())



class MirrorSubObject:
    _hx_class_name = "MirrorSubObject"
    __slots__ = ("detailLevel", "zone", "alphaLevel", "surfaceCount", "surfaceStart", "centroid")
    _hx_fields = ["detailLevel", "zone", "alphaLevel", "surfaceCount", "surfaceStart", "centroid"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.detailLevel = 0
        self.zone = 0
        self.alphaLevel = 0
        self.surfaceCount = 0
        self.surfaceStart = 0
        self.centroid = math_Point3F()

    def write(self,io,version):
        io.writeInt32(self.detailLevel)
        io.writeInt32(self.zone)
        io.writeFloat(self.alphaLevel)
        io.writeInt32(self.surfaceCount)
        io.writeInt32(self.surfaceStart)
        self.centroid.write(io)

    @staticmethod
    def read(io,version):
        ret = MirrorSubObject()
        ret.detailLevel = io.readInt32()
        ret.zone = io.readInt32()
        ret.alphaLevel = io.readFloat()
        ret.surfaceCount = io.readInt32()
        ret.surfaceStart = io.readInt32()
        ret.centroid = math_Point3F.read(io)
        return ret



class NullSurface:
    _hx_class_name = "NullSurface"
    __slots__ = ("windingStart", "planeIndex", "surfaceFlags", "windingCount")
    _hx_fields = ["windingStart", "planeIndex", "surfaceFlags", "windingCount"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.windingStart = 0
        self.planeIndex = 0
        self.surfaceFlags = 0
        self.windingCount = 0

    def write(self,io,version):
        io.writeInt32(self.windingStart)
        io.writeUInt16(self.planeIndex)
        io.writeByte(self.surfaceFlags)
        if (version.interiorVersion >= 13):
            io.writeInt32(self.windingCount)
        else:
            io.writeByte(self.windingCount)

    @staticmethod
    def read(io,version):
        ret = NullSurface()
        ret.windingStart = io.readInt32()
        ret.planeIndex = io.readUInt16()
        ret.surfaceFlags = io.readByte()
        if (version.interiorVersion >= 13):
            ret.windingCount = io.readInt32()
        else:
            ret.windingCount = io.readByte()
        return ret



class Plane:
    _hx_class_name = "Plane"
    __slots__ = ("normalIndex", "planeDistance")
    _hx_fields = ["normalIndex", "planeDistance"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,normalIndex,planeDistance):
        self.normalIndex = normalIndex
        self.planeDistance = planeDistance

    def write(self,io):
        io.writeInt16(self.normalIndex)
        io.writeFloat(self.planeDistance)

    @staticmethod
    def read(io):
        return Plane(io.readInt16(),io.readFloat())



class Polyhedron:
    _hx_class_name = "Polyhedron"
    __slots__ = ("pointList", "planeList", "edgeList")
    _hx_fields = ["pointList", "planeList", "edgeList"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.pointList = list()
        self.planeList = list()
        self.edgeList = list()

    def write(self,io):
        def _hx_local_0(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.pointList,_hx_local_0)
        def _hx_local_1(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.planeList,_hx_local_1)
        def _hx_local_2(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.edgeList,_hx_local_2)

    @staticmethod
    def read(io):
        ret = Polyhedron()
        ret.pointList = ReaderExtensions.readArray(io,math_Point3F.read)
        ret.planeList = ReaderExtensions.readArray(io,math_PlaneF.read)
        ret.edgeList = ReaderExtensions.readArray(io,PolyhedronEdge.read)
        return ret



class PolyhedronEdge:
    _hx_class_name = "PolyhedronEdge"
    __slots__ = ("pointIndex0", "pointIndex1", "faceIndex0", "faceIndex1")
    _hx_fields = ["pointIndex0", "pointIndex1", "faceIndex0", "faceIndex1"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,faceIndex0,faceIndex1,pointIndex0,pointIndex1):
        self.pointIndex0 = pointIndex0
        self.pointIndex1 = pointIndex1
        self.faceIndex0 = faceIndex0
        self.faceIndex1 = faceIndex1

    def write(self,io):
        io.writeInt32(self.faceIndex0)
        io.writeInt32(self.faceIndex1)
        io.writeInt32(self.pointIndex0)
        io.writeInt32(self.pointIndex1)

    @staticmethod
    def read(io):
        return PolyhedronEdge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32())



class Portal:
    _hx_class_name = "Portal"
    __slots__ = ("planeIndex", "triFanCount", "triFanStart", "zoneFront", "zoneBack")
    _hx_fields = ["planeIndex", "triFanCount", "triFanStart", "zoneFront", "zoneBack"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,planeIndex,triFanCount,triFanStart,zoneFront,zoneBack):
        self.planeIndex = planeIndex
        self.triFanCount = triFanCount
        self.triFanStart = triFanStart
        self.zoneFront = zoneFront
        self.zoneBack = zoneBack

    def write(self,io):
        io.writeUInt16(self.planeIndex)
        io.writeUInt16(self.triFanCount)
        io.writeInt32(self.triFanStart)
        io.writeUInt16(self.zoneFront)
        io.writeUInt16(self.zoneBack)

    @staticmethod
    def read(io):
        return Portal(io.readUInt16(),io.readUInt16(),io.readInt32(),io.readUInt16(),io.readUInt16())



class ReaderExtensions:
    _hx_class_name = "ReaderExtensions"
    __slots__ = ()
    _hx_statics = ["readDictionary", "readArray", "readArrayAs", "readArrayFlags", "readPNG", "readColorF"]

    @staticmethod
    def readDictionary(io):
        _hx_len = io.readInt32()
        _hx_dict = haxe_ds_StringMap()
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            name = io.readStr()
            value = io.readStr()
            _hx_dict.h[name] = value
        return _hx_dict

    @staticmethod
    def readArray(io,readMethod):
        _hx_len = io.readInt32()
        arr = list()
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = readMethod(io)
            arr.append(x)
        return arr

    @staticmethod
    def readArrayAs(io,test,failMethod,passMethod):
        length = io.readInt32()
        signed = False
        param = 0
        if (((length & -2147483648)) == -2147483648):
            length = (length ^ -2147483648)
            signed = True
            param = io.readByte()
        array = list()
        _g = 0
        _g1 = length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if test(signed,param):
                x = passMethod(io)
                array.append(x)
            else:
                x1 = failMethod(io)
                array.append(x1)
        return array

    @staticmethod
    def readArrayFlags(io,readMethod):
        length = io.readInt32()
        flags = io.readInt32()
        array = list()
        _g = 0
        _g1 = length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = readMethod(io)
            array.append(x)
        return array

    @staticmethod
    def readPNG(io):
        footer = [73, 69, 78, 68, 174, 66, 96, 130]
        data = []
        while True:
            x = io.readByte()
            data.append(x)
            if (len(data) >= 8):
                match = True
                _g = 0
                while (_g < 8):
                    i = _g
                    _g = (_g + 1)
                    if (python_internal_ArrayImpl._get(data, (i + ((len(data) - 8)))) != (footer[i] if i >= 0 and i < len(footer) else None)):
                        match = False
                        break
                if match:
                    break
        return data

    @staticmethod
    def readColorF(io):
        return [io.readByte(), io.readByte(), io.readByte(), io.readByte()]


class StateData:
    _hx_class_name = "StateData"
    __slots__ = ("surfaceIndex", "mapIndex", "lightStateIndex")
    _hx_fields = ["surfaceIndex", "mapIndex", "lightStateIndex"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,surfaceIndex,mapIndex,lightStateIndex):
        self.surfaceIndex = surfaceIndex
        self.mapIndex = mapIndex
        self.lightStateIndex = lightStateIndex

    def write(self,io):
        io.writeInt32(self.surfaceIndex)
        io.writeInt32(self.mapIndex)
        io.writeInt16(self.lightStateIndex)

    @staticmethod
    def read(io):
        return StateData(io.readInt32(),io.readInt32(),io.readInt16())



class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["isOfType", "string"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class Surface:
    _hx_class_name = "Surface"
    __slots__ = ("windingStart", "windingCount", "planeIndex", "planeFlipped", "textureIndex", "texGenIndex", "surfaceFlags", "fanMask", "lightMapFinalWord", "lightMapTexGenXD", "lightMapTexGenYD", "lightCount", "lightStateInfoStart", "mapOffsetX", "mapOffsetY", "mapSizeX", "mapSizeY", "brushId")
    _hx_fields = ["windingStart", "windingCount", "planeIndex", "planeFlipped", "textureIndex", "texGenIndex", "surfaceFlags", "fanMask", "lightMapFinalWord", "lightMapTexGenXD", "lightMapTexGenYD", "lightCount", "lightStateInfoStart", "mapOffsetX", "mapOffsetY", "mapSizeX", "mapSizeY", "brushId"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.planeFlipped = None
        self.windingStart = 0
        self.windingCount = 0
        self.planeIndex = 0
        self.textureIndex = 0
        self.texGenIndex = 0
        self.surfaceFlags = 0
        self.fanMask = 0
        self.lightMapFinalWord = 0
        self.lightMapTexGenXD = 0
        self.lightMapTexGenYD = 0
        self.lightCount = 0
        self.lightStateInfoStart = 0
        self.mapOffsetX = 0
        self.mapOffsetY = 0
        self.mapSizeX = 0
        self.mapSizeY = 0
        self.brushId = 0

    def write(self,io,version):
        io.writeInt32(self.windingStart)
        if (version.interiorVersion >= 13):
            io.writeInt32(self.windingCount)
        else:
            io.writeByte((self.windingCount & 255))
        pindex = (self.planeIndex | ((32768 if (self.planeFlipped) else 0)))
        io.writeInt16(pindex)
        io.writeInt16(self.textureIndex)
        io.writeInt32(self.texGenIndex)
        io.writeByte(self.surfaceFlags)
        io.writeInt32(self.fanMask)
        io.writeInt16(self.lightMapFinalWord)
        io.writeFloat(self.lightMapTexGenXD)
        io.writeFloat(self.lightMapTexGenYD)
        io.writeInt16(self.lightCount)
        io.writeInt32(self.lightStateInfoStart)
        if (version.interiorVersion >= 13):
            io.writeInt32(self.mapOffsetX)
            io.writeInt32(self.mapOffsetY)
            io.writeInt32(self.mapSizeX)
            io.writeInt32(self.mapSizeY)
        elif (((version.interiorVersion == 0) and ((version.interiorType == "tge"))) and version.useLargeLightmaps):
            io.writeUInt16(self.mapOffsetX)
            io.writeUInt16(self.mapOffsetY)
            io.writeUInt16(self.mapSizeX)
            io.writeUInt16(self.mapSizeY)
        else:
            io.writeByte(self.mapOffsetX)
            io.writeByte(self.mapOffsetY)
            io.writeByte(self.mapSizeX)
            io.writeByte(self.mapSizeY)
        if ((version.interiorType != "tge") and ((version.interiorType != "mbg"))):
            io.writeByte(0)
            if ((version.interiorVersion >= 2) and ((version.interiorVersion <= 5))):
                io.writeInt32(self.brushId)

    @staticmethod
    def read(io,version,interior):
        ret = Surface()
        ret.windingStart = io.readInt32()
        if (len(interior.windings) <= ret.windingStart):
            raise haxe_Exception("DIF Type Error interior.windings.length <= ret.windingStart")
        if (version.interiorVersion >= 13):
            ret.windingCount = io.readInt32()
        else:
            ret.windingCount = io.readByte()
        if ((ret.windingStart + ret.windingCount) > len(interior.windings)):
            raise haxe_Exception("DIF Type Error ret.windingStart + ret.windingCount > interior.windings.length")
        planeIndex = io.readInt16()
        ret.planeFlipped = ((planeIndex >> 15) != 0)
        planeIndexTemp = (planeIndex & -32769)
        if (((planeIndexTemp & -32769)) >= len(interior.planes)):
            raise haxe_Exception("DIF Type Error (planeIndexTemp & ~0x8000) >= interior.planes.length")
        ret.planeIndex = planeIndexTemp
        ret.textureIndex = io.readInt16()
        if (ret.textureIndex >= len(interior.materialList)):
            raise haxe_Exception("DIF Type Error ret.textureIndex >= interior.materialList.length")
        ret.texGenIndex = io.readInt32()
        if (ret.texGenIndex >= len(interior.texGenEQs)):
            raise haxe_Exception("DIF Type Error ret.texGenIndex >= interior.texGenEQs.length")
        ret.surfaceFlags = io.readByte()
        ret.fanMask = io.readInt32()
        ret.lightMapFinalWord = io.readInt16()
        ret.lightMapTexGenXD = io.readFloat()
        ret.lightMapTexGenYD = io.readFloat()
        ret.lightCount = io.readInt16()
        ret.lightStateInfoStart = io.readInt32()
        if (version.interiorVersion >= 13):
            ret.mapOffsetX = io.readInt32()
            ret.mapOffsetY = io.readInt32()
            ret.mapSizeX = io.readInt32()
            ret.mapSizeY = io.readInt32()
        elif (((version.interiorVersion == 0) and ((version.interiorType == "tge"))) and version.useLargeLightmaps):
            ret.mapOffsetX = io.readUInt16()
            ret.mapOffsetY = io.readUInt16()
            ret.mapSizeX = io.readUInt16()
            ret.mapSizeY = io.readUInt16()
        else:
            ret.mapOffsetX = io.readByte()
            ret.mapOffsetY = io.readByte()
            ret.mapSizeX = io.readByte()
            ret.mapSizeY = io.readByte()
        if ((version.interiorType != "tge") and ((version.interiorType != "mbg"))):
            io.readByte()
            if ((version.interiorVersion >= 2) and ((version.interiorVersion <= 5))):
                ret.brushId = io.readInt32()
        return ret



class TexGenEQ:
    _hx_class_name = "TexGenEQ"
    __slots__ = ("planeX", "planeY")
    _hx_fields = ["planeX", "planeY"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.planeX = math_PlaneF()
        self.planeY = math_PlaneF()

    def write(self,io):
        self.planeX.write(io)
        self.planeY.write(io)

    @staticmethod
    def read(io):
        ret = TexGenEQ()
        ret.planeX = math_PlaneF.read(io)
        ret.planeY = math_PlaneF.read(io)
        return ret



class TexMatrix:
    _hx_class_name = "TexMatrix"
    __slots__ = ("t", "n", "b")
    _hx_fields = ["t", "n", "b"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.t = 0
        self.n = 0
        self.b = 0

    def write(self,io):
        io.writeInt32(self.t)
        io.writeInt32(self.n)
        io.writeInt32(self.b)

    @staticmethod
    def read(io):
        ret = TexMatrix()
        ret.t = io.readInt32()
        ret.n = io.readInt32()
        ret.b = io.readInt32()
        return ret



class Trigger:
    _hx_class_name = "Trigger"
    __slots__ = ("name", "datablock", "properties", "polyhedron", "offset")
    _hx_fields = ["name", "datablock", "properties", "polyhedron", "offset"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.name = ""
        self.datablock = ""
        self.offset = math_Point3F()
        self.properties = haxe_ds_StringMap()
        self.polyhedron = Polyhedron()

    def write(self,io):
        io.writeStr(self.name)
        io.writeStr(self.datablock)
        WriterExtensions.writeDictionary(io,self.properties)
        self.polyhedron.write(io)
        self.offset.write(io)

    @staticmethod
    def read(io):
        ret = Trigger()
        ret.name = io.readStr()
        ret.datablock = io.readStr()
        ret.properties = ReaderExtensions.readDictionary(io)
        ret.polyhedron = Polyhedron.read(io)
        ret.offset = math_Point3F.read(io)
        return ret



class VehicleCollision:
    _hx_class_name = "VehicleCollision"
    __slots__ = ("vehicleCollisionFileVersion", "convexHulls", "convexHullEmitStrings", "hullIndices", "hullPlaneIndices", "hullEmitStringIndices", "hullSurfaceIndices", "polyListPlanes", "polyListPoints", "polyListStrings", "nullSurfaces", "points", "planes", "windings", "windingIndices")
    _hx_fields = ["vehicleCollisionFileVersion", "convexHulls", "convexHullEmitStrings", "hullIndices", "hullPlaneIndices", "hullEmitStringIndices", "hullSurfaceIndices", "polyListPlanes", "polyListPoints", "polyListStrings", "nullSurfaces", "points", "planes", "windings", "windingIndices"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.windingIndices = None
        self.windings = None
        self.planes = None
        self.points = None
        self.nullSurfaces = None
        self.polyListStrings = None
        self.polyListPoints = None
        self.polyListPlanes = None
        self.hullSurfaceIndices = None
        self.hullEmitStringIndices = None
        self.hullPlaneIndices = None
        self.hullIndices = None
        self.convexHullEmitStrings = None
        self.convexHulls = None
        self.vehicleCollisionFileVersion = None

    def write(self,io,version):
        io.writeInt32(self.vehicleCollisionFileVersion)
        def _hx_local_0(io,p):
            p.write(io,version)
        WriterExtensions.writeArray(io,self.convexHulls,_hx_local_0)
        def _hx_local_1(io,p):
            io.writeByte(p)
        WriterExtensions.writeArray(io,self.convexHullEmitStrings,_hx_local_1)
        def _hx_local_2(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullIndices,_hx_local_2)
        def _hx_local_3(io,p):
            io.writeInt16(p)
        WriterExtensions.writeArray(io,self.hullPlaneIndices,_hx_local_3)
        def _hx_local_4(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullEmitStringIndices,_hx_local_4)
        def _hx_local_5(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.hullSurfaceIndices,_hx_local_5)
        def _hx_local_6(io,p):
            io.writeInt16(p)
        WriterExtensions.writeArray(io,self.polyListPlanes,_hx_local_6)
        def _hx_local_7(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.polyListPoints,_hx_local_7)
        def _hx_local_8(io,p):
            io.writeByte(p)
        WriterExtensions.writeArray(io,self.polyListStrings,_hx_local_8)
        def _hx_local_9(io,p):
            p.write(io,Version())
        WriterExtensions.writeArray(io,self.nullSurfaces,_hx_local_9)
        def _hx_local_10(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.points,_hx_local_10)
        def _hx_local_11(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.planes,_hx_local_11)
        def _hx_local_12(io,p):
            io.writeInt32(p)
        WriterExtensions.writeArray(io,self.windings,_hx_local_12)
        def _hx_local_13(io,p):
            p.write(io)
        WriterExtensions.writeArray(io,self.windingIndices,_hx_local_13)

    @staticmethod
    def read(io,version):
        ret = VehicleCollision()
        ret.vehicleCollisionFileVersion = io.readInt32()
        def _hx_local_0(io):
            return ConvexHull.read(io,version)
        ret.convexHulls = ReaderExtensions.readArray(io,_hx_local_0)
        def _hx_local_1(io):
            return io.readByte()
        ret.convexHullEmitStrings = ReaderExtensions.readArray(io,_hx_local_1)
        def _hx_local_2(io):
            return io.readInt32()
        ret.hullIndices = ReaderExtensions.readArray(io,_hx_local_2)
        def _hx_local_3(io):
            return io.readInt16()
        ret.hullPlaneIndices = ReaderExtensions.readArray(io,_hx_local_3)
        def _hx_local_4(io):
            return io.readInt32()
        ret.hullEmitStringIndices = ReaderExtensions.readArray(io,_hx_local_4)
        def _hx_local_5(io):
            return io.readInt32()
        ret.hullSurfaceIndices = ReaderExtensions.readArray(io,_hx_local_5)
        def _hx_local_6(io):
            return io.readInt16()
        ret.polyListPlanes = ReaderExtensions.readArray(io,_hx_local_6)
        def _hx_local_7(io):
            return io.readInt32()
        ret.polyListPoints = ReaderExtensions.readArray(io,_hx_local_7)
        def _hx_local_8(io):
            return io.readByte()
        ret.polyListStrings = ReaderExtensions.readArray(io,_hx_local_8)
        def _hx_local_9(io):
            return NullSurface.read(io,Version())
        ret.nullSurfaces = ReaderExtensions.readArray(io,_hx_local_9)
        ret.points = ReaderExtensions.readArray(io,math_Point3F.read)
        ret.planes = ReaderExtensions.readArray(io,Plane.read)
        def _hx_local_10(io):
            return io.readInt32()
        ret.windings = ReaderExtensions.readArray(io,_hx_local_10)
        ret.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read)
        return ret



class Version:
    _hx_class_name = "Version"
    __slots__ = ("difVersion", "interiorVersion", "interiorType", "useLargeLightmaps")
    _hx_fields = ["difVersion", "interiorVersion", "interiorType", "useLargeLightmaps"]

    def __init__(self):
        self.difVersion = 44
        self.interiorVersion = 0
        self.interiorType = "?"
        self.useLargeLightmaps = False



class WayPoint:
    _hx_class_name = "WayPoint"
    __slots__ = ("position", "rotation", "msToNext", "smoothingType")
    _hx_fields = ["position", "rotation", "msToNext", "smoothingType"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,position,rotation,msToNext,smoothingType):
        self.position = position
        self.rotation = rotation
        self.msToNext = msToNext
        self.smoothingType = smoothingType

    def write(self,io):
        self.position.write(io)
        self.rotation.write(io)
        io.writeInt32(self.msToNext)
        io.writeInt32(self.smoothingType)

    @staticmethod
    def read(io):
        return WayPoint(math_Point3F.read(io),math_QuatF.read(io),io.readInt32(),io.readInt32())



class WindingIndex:
    _hx_class_name = "WindingIndex"
    __slots__ = ("windingStart", "windingCount")
    _hx_fields = ["windingStart", "windingCount"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self,windingStart,windingCount):
        self.windingStart = windingStart
        self.windingCount = windingCount

    def write(self,io):
        io.writeInt32(self.windingStart)
        io.writeInt32(self.windingCount)

    @staticmethod
    def read(io):
        return WindingIndex(io.readInt32(),io.readInt32())



class WriterExtensions:
    _hx_class_name = "WriterExtensions"
    __slots__ = ()
    _hx_statics = ["writeDictionary", "writeArray", "writeArrayFlags", "writePNG", "writeColorF"]

    @staticmethod
    def writeDictionary(io,_hx_dict):
        _hx_len = 0
        key = _hx_dict.keys()
        while key.hasNext():
            key1 = key.next()
            _hx_len = (_hx_len + 1)
        _hx_map = _hx_dict
        _g_map = _hx_map
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            kvp_value = _g_map.get(key)
            kvp_key = key
            io.writeStr(kvp_key)
            io.writeStr(kvp_value)

    @staticmethod
    def writeArray(io,arr,writeMethod):
        io.writeInt32(len(arr))
        _g = 0
        _g1 = len(arr)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            writeMethod(io,(arr[i] if i >= 0 and i < len(arr) else None))
        return arr

    @staticmethod
    def writeArrayFlags(io,arr,flags,writeMethod):
        io.writeInt32(len(arr))
        io.writeInt32(flags)
        _g = 0
        _g1 = len(arr)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            writeMethod(io,(arr[i] if i >= 0 and i < len(arr) else None))

    @staticmethod
    def writePNG(io,arr):
        _g = 0
        _g1 = len(arr)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            io.writeByte((arr[i] if i >= 0 and i < len(arr) else None))

    @staticmethod
    def writeColorF(io,color):
        io.writeByte((color[0] if 0 < len(color) else None))
        io.writeByte((color[1] if 1 < len(color) else None))
        io.writeByte((color[2] if 2 < len(color) else None))
        io.writeByte((color[3] if 3 < len(color) else None))


class Zone:
    _hx_class_name = "Zone"
    __slots__ = ("portalStart", "portalCount", "surfaceStart", "surfaceCount", "staticMeshStart", "staticMeshCount", "flags")
    _hx_fields = ["portalStart", "portalCount", "surfaceStart", "surfaceCount", "staticMeshStart", "staticMeshCount", "flags"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.portalStart = 0
        self.portalCount = 0
        self.surfaceStart = 0
        self.surfaceCount = 0
        self.staticMeshStart = 0
        self.staticMeshCount = 0
        self.flags = 0

    def write(self,io,version):
        io.writeInt16(self.portalStart)
        io.writeInt16(self.portalCount)
        io.writeInt32(self.surfaceStart)
        if ((version.interiorType == "tgea") or ((version.interiorType == "tge"))):
            if ((version.interiorVersion >= 14) or ((version.interiorVersion == 0))):
                io.writeUInt16(self.surfaceCount)
            else:
                io.writeInt32(self.surfaceCount)
        else:
            io.writeInt32(self.surfaceCount)
        if (version.interiorVersion >= 12):
            io.writeInt32(self.staticMeshStart)
            io.writeInt32(self.staticMeshCount)
        if ((version.interiorType == "tgea") or ((version.interiorType == "tge"))):
            if ((version.interiorVersion >= 14) or ((version.interiorVersion == 0))):
                io.writeUInt16(self.flags)

    @staticmethod
    def read(io,version):
        ret = Zone()
        ret.portalStart = io.readUInt16()
        ret.portalCount = io.readUInt16()
        ret.surfaceStart = io.readInt32()
        if ((version.interiorType == "tgea") or ((version.interiorType == "tge"))):
            if ((version.interiorVersion >= 14) or ((version.interiorVersion == 0))):
                ret.surfaceCount = io.readUInt16()
            else:
                ret.surfaceCount = io.readInt32()
        else:
            ret.surfaceCount = io.readInt32()
        if (version.interiorVersion >= 12):
            ret.staticMeshStart = io.readInt32()
            ret.staticMeshCount = io.readInt32()
        if ((version.interiorType == "tgea") or ((version.interiorType == "tge"))):
            if ((version.interiorVersion >= 14) or ((version.interiorVersion == 0))):
                ret.flags = io.readUInt16()
        return ret



class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "keys"]


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e



class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))



class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))



class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "getFloat"]
    _hx_statics = ["alloc", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def getFloat(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        return haxe_io_FPHelper.i32ToFloat(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)



class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["addInt32", "getBytes"]

    def __init__(self):
        self.b = bytearray()

    def addInt32(self,v):
        self.b.append((v & 255))
        self.b.append(((v >> 8) & 255))
        self.b.append(((v >> 16) & 255))
        self.b.append(HxOverrides.rshift(v, 24))

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes



class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    __slots__ = ()
    _hx_statics = ["i32ToFloat", "floatToI32"]

    @staticmethod
    def i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
            return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        else:
            af = (-f if ((f < 0)) else f)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
            if (exp > 127):
                return 2139095040
            else:
                if (exp <= -127):
                    exp = -127
                    af = (af * 7.1362384635298e+44)
                else:
                    af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
                return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readAll"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readAll(self,bufsize = None):
        if (bufsize is None):
            bufsize = 16384
        buf = haxe_io_Bytes.alloc(bufsize)
        total = haxe_io_BytesBuffer()
        try:
            while True:
                _hx_len = self.readBytes(buf,0,bufsize)
                if (_hx_len == 0):
                    raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
                total.b.extend(buf.b[0:_hx_len])
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return total.getBytes()



class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "write"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)



class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class io_BytesReader:
    _hx_class_name = "io.BytesReader"
    __slots__ = ("bytes", "position")
    _hx_fields = ["bytes", "position"]
    _hx_methods = ["readInt32", "readInt16", "readUInt16", "readByte", "readStr", "readFloat", "tell", "seek"]

    def __init__(self,_hx_bytes):
        self.bytes = _hx_bytes
        self.position = 0

    def readInt32(self):
        _this = self.bytes
        pos = self.position
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        b = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 4)
        _hx_local_0.position
        return b

    def readInt16(self):
        _this = self.bytes
        pos = self.position
        b = (_this.b[pos] | ((_this.b[(pos + 1)] << 8)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 2)
        _hx_local_0.position
        return b

    def readUInt16(self):
        _this = self.bytes
        pos = self.position
        b = (_this.b[pos] | ((_this.b[(pos + 1)] << 8)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 2)
        _hx_local_0.position
        return b

    def readByte(self):
        b = self.bytes.b[self.position]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 1)
        _hx_local_0.position
        return b

    def readStr(self):
        _hx_len = self.readByte()
        _hx_str = ""
        reading = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = self.readByte()
            if (ch == 0):
                reading = False
            if reading:
                _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull("".join(map(chr,[ch]))))
        return _hx_str

    def readFloat(self):
        b = self.bytes.getFloat(self.position)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 4)
        _hx_local_0.position
        return b

    def tell(self):
        return self.position

    def seek(self,pos):
        self.position = pos



class io_BytesWriter:
    _hx_class_name = "io.BytesWriter"
    __slots__ = ("bytes",)
    _hx_fields = ["bytes"]
    _hx_methods = ["writeInt32", "writeUInt16", "writeInt16", "writeByte", "writeStr", "writeFloat", "getBuffer"]

    def __init__(self):
        self.bytes = haxe_io_BytesBuffer()

    def writeInt32(self,_hx_int):
        self.bytes.addInt32(_hx_int)

    def writeUInt16(self,_hx_int):
        h = (_hx_int >> 8)
        l = (_hx_int & 255)
        self.bytes.b.append(l)
        self.bytes.b.append(h)

    def writeInt16(self,_hx_int):
        h = (_hx_int >> 8)
        l = (_hx_int & 255)
        self.bytes.b.append(l)
        self.bytes.b.append(h)

    def writeByte(self,_hx_int):
        self.bytes.b.append(_hx_int)

    def writeStr(self,_hx_str):
        self.bytes.b.append(len(_hx_str))
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            c = _g
            _g = (_g + 1)
            _this = self.bytes
            byte = HxString.charCodeAt(_hx_str,c)
            _this.b.append(byte)

    def writeFloat(self,f):
        self.bytes.addInt32(haxe_io_FPHelper.floatToI32(f))

    def getBuffer(self):
        return self.bytes.getBytes()



class math_Box3F:
    _hx_class_name = "math.Box3F"
    __slots__ = ("minX", "minY", "minZ", "maxX", "maxY", "maxZ")
    _hx_fields = ["minX", "minY", "minZ", "maxX", "maxY", "maxZ"]
    _hx_methods = ["clone", "center", "extend", "Expand", "contains", "getClosestPoint", "write"]
    _hx_statics = ["PointBounds", "read"]

    def __init__(self,minX = None,minY = None,minZ = None,maxX = None,maxY = None,maxZ = None):
        if (minX is None):
            minX = 0.0
        if (minY is None):
            minY = 0.0
        if (minZ is None):
            minZ = 0.0
        if (maxX is None):
            maxX = 0.0
        if (maxY is None):
            maxY = 0.0
        if (maxZ is None):
            maxZ = 0.0
        self.minX = minX
        self.minY = minY
        self.minZ = minZ
        self.maxX = maxX
        self.maxY = maxY
        self.maxZ = maxZ

    def clone(self):
        return math_Box3F(self.minX,self.minY,self.minZ,self.maxX,self.maxY,self.maxZ)

    def center(self):
        return math_Point3F((self.minX + self.maxX),(self.minY + self.maxY),(self.minZ + self.maxZ)).scalarDiv(2)

    def extend(self,box):
        a = self.minX
        b = box.minX
        self.minX = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        a = self.minY
        b = box.minY
        self.minY = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        a = self.minZ
        b = box.minZ
        self.minZ = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        a = self.maxX
        b = box.maxX
        self.maxX = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        a = self.maxY
        b = box.maxY
        self.maxY = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        a = self.maxZ
        b = box.maxZ
        self.maxZ = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))

    def Expand(self,point):
        if (self.minX > point.x):
            self.minX = point.x
        if (self.minY > point.y):
            self.minY = point.y
        if (self.minZ > point.z):
            self.minZ = point.z
        if (self.maxX < point.x):
            self.maxX = point.x
        if (self.maxY < point.y):
            self.maxY = point.y
        if (self.maxZ < point.z):
            self.maxZ = point.z

    def contains(self,p):
        if (((((self.minX <= p.x) and ((p.x <= self.maxX))) and ((self.minY <= p.y))) and ((p.y <= self.maxY))) and ((self.minZ <= p.z))):
            return (p.z <= self.maxZ)
        else:
            return False

    def getClosestPoint(self,point):
        closest = math_Point3F()
        if (self.minX > point.x):
            closest.x = self.minX
        elif (self.maxX < point.x):
            closest.x = self.maxX
        else:
            closest.x = point.x
        if (self.minY > point.y):
            closest.y = self.minY
        elif (self.maxY < point.y):
            closest.y = self.maxY
        else:
            closest.y = point.y
        if (self.minZ > point.z):
            closest.z = self.minZ
        elif (self.maxZ < point.z):
            closest.z = self.maxZ
        else:
            closest.z = point.z
        return closest

    def write(self,io):
        io.writeFloat(self.minX)
        io.writeFloat(self.minY)
        io.writeFloat(self.minZ)
        io.writeFloat(self.maxX)
        io.writeFloat(self.maxY)
        io.writeFloat(self.maxZ)

    @staticmethod
    def PointBounds(point,size):
        ret = math_Box3F()
        ret.minX = point.x
        ret.minY = point.y
        ret.minZ = point.z
        ret.maxX = (point.x + size.x)
        ret.maxY = (point.y + size.y)
        ret.maxZ = (point.z + size.z)
        return ret

    @staticmethod
    def read(io):
        ret = math_Box3F()
        ret.minX = io.readFloat()
        ret.minY = io.readFloat()
        ret.minZ = io.readFloat()
        ret.maxX = io.readFloat()
        ret.maxY = io.readFloat()
        ret.maxZ = io.readFloat()
        return ret



class math_PlaneF:
    _hx_class_name = "math.PlaneF"
    __slots__ = ("x", "y", "z", "d")
    _hx_fields = ["x", "y", "z", "d"]
    _hx_methods = ["write"]
    _hx_statics = ["ThreePoints", "NormalD", "PointNormal", "read"]

    def __init__(self,x = None,y = None,z = None,d = None):
        if (x is None):
            x = 0.0
        if (y is None):
            y = 0.0
        if (z is None):
            z = 0.0
        if (d is None):
            d = 0.0
        self.x = x
        self.y = y
        self.z = z
        self.d = d

    def write(self,io):
        io.writeFloat(self.x)
        io.writeFloat(self.y)
        io.writeFloat(self.z)
        io.writeFloat(self.d)

    @staticmethod
    def ThreePoints(a,b,c):
        v1 = a.sub(b)
        v2 = c.sub(b)
        res = v1.cross(v2)
        ret = math_PlaneF()
        normal = res.normalized()
        ret.x = normal.x
        ret.y = normal.y
        ret.z = normal.z
        ret.d = -b.dot(normal)
        return ret

    @staticmethod
    def NormalD(normal,d):
        ret = math_PlaneF()
        ret.x = normal.x
        ret.y = normal.y
        ret.z = normal.z
        ret.d = d
        return ret

    @staticmethod
    def PointNormal(pt,n):
        ret = math_PlaneF()
        normal = n.normalized()
        ret.x = normal.x
        ret.y = normal.y
        ret.z = normal.z
        ret.d = -pt.dot(normal)
        return ret

    @staticmethod
    def read(io):
        ret = math_PlaneF()
        ret.x = io.readFloat()
        ret.y = io.readFloat()
        ret.z = io.readFloat()
        ret.d = io.readFloat()
        return ret



class math_Point3F:
    _hx_class_name = "math.Point3F"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["get", "set", "add", "sub", "scalar", "scalarDiv", "dot", "cross", "length", "lengthSq", "normalized", "equal", "write", "copy"]
    _hx_statics = ["read"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.0
        if (y is None):
            y = 0.0
        if (z is None):
            z = 0.0
        self.x = x
        self.y = y
        self.z = z

    def get(self,dim):
        if (dim == 0):
            return self.x
        if (dim == 1):
            return self.y
        if (dim == 2):
            return self.z
        return -1

    def set(self,dim,value):
        if (dim == 0):
            self.x = value
        if (dim == 1):
            self.y = value
        if (dim == 2):
            self.z = value

    def add(self,rhs):
        return math_Point3F((self.x + rhs.x),(self.y + rhs.y),(self.z + rhs.z))

    def sub(self,rhs):
        return math_Point3F((self.x - rhs.x),(self.y - rhs.y),(self.z - rhs.z))

    def scalar(self,rhs):
        return math_Point3F((self.x * rhs),(self.y * rhs),(self.z * rhs))

    def scalarDiv(self,rhs):
        return math_Point3F((self.x / rhs),(self.y / rhs),(self.z / rhs))

    def dot(self,rhs):
        return (((self.x * rhs.x) + ((self.y * rhs.y))) + ((self.z * rhs.z)))

    def cross(self,rhs):
        return math_Point3F(((self.y * rhs.z) - ((self.z * rhs.y))),((self.z * rhs.x) - ((self.x * rhs.z))),((self.x * rhs.y) - ((self.y * rhs.x))))

    def length(self):
        v = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def normalized(self):
        if (self.length() != 0):
            return self.scalarDiv(self.length())
        else:
            return self

    def equal(self,other):
        if ((self.x == other.x) and ((self.y == other.y))):
            return (self.z == other.z)
        else:
            return False

    def write(self,io):
        io.writeFloat(self.x)
        io.writeFloat(self.y)
        io.writeFloat(self.z)

    def copy(self):
        return math_Point3F(self.x,self.y,self.z)

    @staticmethod
    def read(io):
        ret = math_Point3F()
        ret.x = io.readFloat()
        ret.y = io.readFloat()
        ret.z = io.readFloat()
        return ret



class math_Point4F:
    _hx_class_name = "math.Point4F"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.w = 0

    def write(self,io):
        io.writeFloat(self.x)
        io.writeFloat(self.y)
        io.writeFloat(self.z)
        io.writeFloat(self.w)

    @staticmethod
    def read(io):
        ret = math_Point4F()
        ret.x = io.readFloat()
        ret.y = io.readFloat()
        ret.z = io.readFloat()
        ret.w = io.readFloat()
        return ret



class math_QuatF:
    _hx_class_name = "math.QuatF"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.w = 0

    def write(self,io):
        io.writeFloat(self.x)
        io.writeFloat(self.y)
        io.writeFloat(self.z)
        io.writeFloat(self.w)

    @staticmethod
    def read(io):
        ret = math_QuatF()
        ret.x = io.readFloat()
        ret.y = io.readFloat()
        ret.z = io.readFloat()
        ret.w = io.readFloat()
        return ret



class math_Spheref:
    _hx_class_name = "math.Spheref"
    __slots__ = ("originX", "originY", "originZ", "radius")
    _hx_fields = ["originX", "originY", "originZ", "radius"]
    _hx_methods = ["write"]
    _hx_statics = ["read"]

    def __init__(self):
        self.originX = 0
        self.originY = 0
        self.originZ = 0
        self.radius = 0

    def write(self,io):
        io.writeFloat(self.originX)
        io.writeFloat(self.originY)
        io.writeFloat(self.originZ)
        io.writeFloat(self.radius)

    @staticmethod
    def read(io):
        ret = math_Spheref()
        ret.originX = io.readFloat()
        ret.originY = io.readFloat()
        ret.originZ = io.readFloat()
        ret.radius = io.readFloat()
        return ret



class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["_get"]

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["charCodeAt", "substr"]

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret



class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readAll"]


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def readinto(self,b):
        return self.stream.readinto(b)



class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")



class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "write"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def readinto(self,b):
        return self.stream.buffer.readinto(b)



class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))



class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["read", "write"]

    @staticmethod
    def read(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def write(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("wb" if binary else "w")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readAll"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def readAll(self,bufsize = None):
        return self.impl.readAll(bufsize)



class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def write(self,s):
        self.impl.write(s)


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")